#include "Bullet.h"

using namespace tdr;

fix1616 tdr::operator+(fix1616 a, fix1616 b) {
	if (b.u > 0 && ((int32_t) 0xFFFFFFFF) - b.u < a.u)
		return { (int32_t) 0xFFFFFFFF };
	if (b.u < 0 && -((int32_t) 0xFFFFFFFF) - b.u > a.u)
		return { -((int32_t) 0xFFFFFFFF) };
	return { a.u + b.u };
}
fix1616 tdr::operator-(fix1616 a, fix1616 b) {
	if (b.u > 0 && -((int32_t) 0xFFFFFFFF) + b.u < a.u)
		return { -(int32_t) 0xFFFFFFFF };
	if (b.u < 0 && ((int32_t) 0xFFFFFFFF) + b.u > a.u)
		return { ((int32_t) 0xFFFFFFFF) };
	return { a.u - b.u };
}
fix1616 tdr::operator*(fix1616 a, fix1616 b) {
	int64_t prod = (((int64_t) a.u) * b.u) >> 16;
	if (prod >= 0x100000000) prod = 0xFFFFFFFF;
	if (prod < -((int64_t) 0x100000000)) prod = -((int64_t) 0xFFFFFFFF);
	return { (int32_t) prod };
}
fix1616 tdr::operator/(fix1616 a, fix1616 b) {
	int64_t aex = (((int64_t) a.u) << 16);
	int64_t res = aex / b.u;
	if (res > ((int64_t) 0xFFFFFFFF)) return { (int32_t) 0xFFFFFFFF };
	if (res < -((int64_t) 0xFFFFFFFF)) return { -((int32_t) 0xFFFFFFFF) };
	return { (int32_t) res };
}

bool tdr::operator==(fix1616 a, fix1616 b) {
	return a.u == b.u;
}

bool tdr::operator<(fix1616 a, fix1616 b) {
	return a.u < b.u;
}

#define TAU_TIMES_2TT28 0x6487ED51
#define CORDIC_ITERATIONS 31
#define CORDIC_K 0x26DD3B6A

// Generated by this Perl6 expression:
// ((^32).map({"0x"~(2**30*atan(2**-$_)).floor.base(16)})).join(", ")
const int32_t arctangents[] = { 0x3243F6A8, 0x1DAC6705, 0xFADBAFC, 0x7F56EA6, 0x3FEAB76, 0x1FFD55B, 0xFFFAAA, 0x7FFF55, 0x3FFFEA, 0x1FFFFD, 0xFFFFF, 0x7FFFF, 0x3FFFF, 0x1FFFF, 0xFFFF, 0x7FFF, 0x3FFF, 0x1FFF, 0xFFF, 0x7FF, 0x3FF, 0x1FF, 0xFF, 0x7F, 0x3F, 0x1F, 0xF, 0x8, 0x4, 0x2, 0x1, 0x0 };

// Calculates sine and cosine using CORDIC
// (https://en.wikipedia.org/wiki/CORDIC)
// t = angle in 1/65536 of a turn
// c = reference to where you want cosine to be stored
// s = reference to where you want sine to be stored
void tdr::sincos(fix1616 t, fix1616& c, fix1616& s) {
	if (t.u > 0x40000000 || t.u < -((int32_t) 0x40000000))
		t.u += 0x80000000; // Plus, minus, that doesn't even matter ~
	// Multiply by tau to convert turns into radians
	// (in 32.32 format)
	int32_t radians = (int32_t) ((((int64_t) t.u) * TAU_TIMES_2TT28) >> 28);
	// vx and vy use 2.30 format
	// (to be able to represent both 1 and -1)
	int32_t vx = CORDIC_K;
	int32_t vy = 0;
	int32_t power = 0x40000000;
	for (int i = 0; i < CORDIC_ITERATIONS; ++i) {
		// new vector = [1, -factor; factor, 1] old vector
		int factor = power;
		if (radians < 0) factor = -factor;
		int32_t nx = vx - factor * vy;
		int32_t ny = factor * vx + vy;
		vx = nx;
		vy = ny;
		radians -= (radians < 0) ? -arctangents[i] : arctangents[i];
		power >>= 1;
	}
	// Convert raw values into fix1616's
	c = { vx >> 14 };
	s = { vy >> 14 };
}

