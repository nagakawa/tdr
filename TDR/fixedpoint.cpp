#include "fixedpoint.h"

#include <cmath>

using namespace tdr;

fix1616 tdr::clamp(fix1616 x, fix1616 a, fix1616 b) {
  return max(a, min(b, x));
}

fix1616 tdr::operator+(fix1616 a,fix1616 b) {
	if (b.u > 0 && ((int32_t) CELESTIAL) - b.u < a.u)
		return { (int32_t) CELESTIAL };
	if (b.u < 0 && ((int32_t) ABYSS) - b.u > a.u)
		return { ((int32_t) ABYSS) };
	return { a.u + b.u };
}
fix1616 tdr::operator-(fix1616 a,fix1616 b) {
	if (b.u > 0 && -((int32_t) CELESTIAL) + b.u < a.u)
		return { -(int32_t) CELESTIAL };
	if (b.u < 0 && ((int32_t) ABYSS) + b.u > a.u)
		return { ((int32_t) ABYSS) };
	return { a.u - b.u };
}
fix1616 tdr::fix1616::addWrap(fix1616 b) const {
  return { (int32_t) ((uint32_t) u + (uint32_t) b.u) };
}
fix1616 tdr::fix1616::subWrap(fix1616 b) const {
  return { (int32_t) ((uint32_t) u - (uint32_t) b.u) };
}
fix1616 tdr::operator-(fix1616 a) {
	if (a.u == ABYSS) return { CELESTIAL };
  else return { -a.u };
}
fix1616 tdr::operator*(fix1616 a, fix1616 b) {
	int64_t prod = (((int64_t) a.u) * b.u) >> 16;
	if (prod >= 0x100000000) prod = CELESTIAL;
	if (prod < -((int64_t) 0x100000000)) prod = ((int64_t) ABYSS);
	return { (int32_t) prod };
}
fix1616 tdr::operator/(fix1616 a, fix1616 b) {
	int64_t aex = (((int64_t) a.u) << 16);
	int64_t res = aex / b.u;
	if (res > CELESTIAL) return { CELESTIAL };
	if (res < ABYSS) return { ABYSS };
	return { (int32_t) res };
}

bool tdr::operator==(fix1616 a, fix1616 b) {
	return a.u == b.u;
}

bool tdr::operator!=(fix1616 a, fix1616 b) {
	return a.u != b.u;
}

bool tdr::operator<(fix1616 a, fix1616 b) {
	return a.u < b.u;
}

bool tdr::operator>(fix1616 a, fix1616 b) {
	return a.u > b.u;
}

bool tdr::operator>=(fix1616 a, fix1616 b) {
	return a.u >= b.u;
}

bool tdr::operator==(fix1616 a, int b) {
	if (b < -0x8000 || b >= 0x8000) return false;
  return (b << 16) == a.u;
}

bool tdr::operator!=(fix1616 a, int b) {
	if (b < -0x8000 || b >= 0x8000) return true;
  return (b << 16) != a.u;
}

bool tdr::operator<(fix1616 a, int b) {
  if (b < -0x8000) return false;
  if (b >= 0x8000) return true;
  return (b << 16) < a.u;
}

bool tdr::operator>(fix1616 a, int b) {
  if (b < -0x8000) return true;
  if (b >= 0x8000) return false;
  return (b << 16) > a.u;
}

bool tdr::operator==(int a, fix1616 b) {
  return b == a;
}

bool tdr::operator!=(int a, fix1616 b) {
  return b != a;
}

bool tdr::operator<(int a, fix1616 b) {
  return b > a;
}

bool tdr::operator>(int a, fix1616 b) {
  return b < a;
}

fix1616 tdr::fix1616::operator+=(fix1616 b) {
  u = ((*this) + b).u;
  return *this;
}

fix1616 tdr::fix1616::operator-=(fix1616 b) {
  u = ((*this) - b).u;
  return *this;
}

fix1616 tdr::fix1616::operator=(int b) {
  if (b >= 0x8000) u = CELESTIAL;
  else if (b < -0x8000) u = ABYSS;
  else u = b << 16;
  return *this;
}

fix1616 tdr::max(fix1616 a, fix1616 b) {
  return (a > b) ? a : b;
}

fix1616 tdr::min(fix1616 a, fix1616 b) {
  return (a < b) ? a : b;
}

// Adapted from:
// http://www.codecodex.com/wiki/Calculate_an_integer_square_root
int32_t tdr::sqrti(int64_t n) {
  if (n < 0) throw "Positive n expected in tdr::sqrti";
  int64_t root = 0;
  int64_t rem = n;
  int64_t place = 0x4000'0000'0000'0000; //' // < this compiles, but
  while (place > rem) place >>= 2; // the commented quote was inserted
  while (place != 0) {             // to avoid throwing C++14-unaware
    if (rem >= root + place) {     // syntax highlighters off
      rem -= root + place;
      root += place << 1;
    }
    root >>= 1;
    place >>= 2;
  }
  return (int32_t) root;
}

bool tdr::isWithin(fix1616 x, fix1616 y, fix1616 r) {
	uint64_t distsq = ((int64_t) x.u) * x.u + ((int64_t) y.u) * y.u;
	uint64_t thresh = ((int64_t) r.u) * r.u;
	return distsq <= thresh;
}

fix1616 tdr::hypotx(fix1616 x, fix1616 y) {
  uint64_t distsq = ((int64_t) x.u) * x.u + ((int64_t) y.u) * y.u;
  return { sqrti(distsq) };
}

fix1616 tdr::multiply1616By230(fix1616 a, int32_t b) {
	int64_t res = ((int64_t) a.u) * b >> 30;
	return { (int32_t) res };
}

#define TAU_TIMES_2TT28 0x6487ED51
#define CORDIC_ITERATIONS 31
// CORDIC K constant in 2.30 format.
#define CORDIC_K 0x26DD3B6A

inline int32_t mul230(int32_t a, int32_t b) {
  int64_t aa = a;
  aa *= b;
  return (int32_t) (aa >> 30);
}

// Generated by this Perl6 expression:
// ((^32).map({"0x"~(2**30*atan(2**-$_)).floor.base(16)})).join(", ")
const int32_t arctangents[] = {
  0x3243F6A8, 0x1DAC6705, 0xFADBAFC, 0x7F56EA6,
  0x3FEAB76, 0x1FFD55B, 0xFFFAAA, 0x7FFF55,
  0x3FFFEA, 0x1FFFFD, 0xFFFFF, 0x7FFFF,
  0x3FFFF, 0x1FFFF, 0xFFFF, 0x7FFF,
  0x3FFF, 0x1FFF, 0xFFF, 0x7FF,
  0x3FF, 0x1FF, 0xFF, 0x7F,
  0x3F, 0x1F, 0xF, 0x8,
  0x4, 0x2, 0x1, 0x0
};

// A list of ratios to intermediate K-values, in 2.30 format.
// Generated by this Perl6 expression:
// my @inv = (0..^32).map({1/sqrt(1+2**(-2*$_))});
// say ([\*] @inv).map({"0x" ~ floor(2**30*$_).base(16)}).join(", ");
const int32_t intermediateK[] = {
  0x40000000, 0x2D413CCD, 0x287A26C5, 0x2744C375,
  0x26F72284, 0x26E3B583, 0x26DED9F5, 0x26DDA30D,
  0x26DD5553, 0x26DD41E4, 0x26DD3D09, 0x26DD3BD2,
  0x26DD3B84, 0x26DD3B71, 0x26DD3B6C
};

// A list of ratios to intermediate K-values to CORDIC_K, in 2.30 format.
// Generated by this Perl6 expression:
// my @inv = (0..^32).map({1/sqrt(1+2**(-2*$_))});
// say ([\*] @inv).map({"0x" ~ floor(2**30*$_/([*] @inv)).base(16)}).join(", ");
const int32_t intermediateKRatio[] = {
  0x69648523, 0x4A861BD3, 0x42A7FAAB, 0x40AA7DCD,
  0x402AA7D5, 0x400AAA7D, 0x4002AAA7, 0x4000AAAA,
  0x40002AAA, 0x40000AAA, 0x400002AA, 0x400000AA,
  0x4000002A, 0x4000000A, 0x40000002
};

// Calculates sine and cosine using CORDIC
// (https://en.wikipedia.org/wiki/CORDIC)
// t = angle in 1/65536 of a turn
// c = reference to where you want cosine to be stored
// s = reference to where you want sine to be stored
// Both of the results will be stored in 2.30 format.
void tdr::sincos(fix1616 t, int32_t& c, int32_t& s) {
	bool inv = t.u > 0x40000000 || t.u < -((int32_t) 0x40000000);
	if (inv) // Plus, minus, that doesn't even matter ~
		t.u = (int32_t) (((uint32_t) t.u) + 0x80000000); // avoid UB
	// Multiply by tau to convert turns into radians (in 34.30 format)
  // No idea why we need to shift right by THIRTY, though.
	int64_t radians = ((((int64_t) t.u) * TAU_TIMES_2TT28) >> 30);
	// vx and vy use 2.30 format
	// (to be able to represent both 1 and -1)
	int32_t vx = CORDIC_K;
	int32_t vy = 0;
  unsigned int i;
	for (i = 0; i < CORDIC_ITERATIONS && radians != 0; ++i) {
		// new vector = [1, -factor; factor, 1] old vector
    int32_t nx, ny;
		if (radians >= 0) {
      nx = vx - (vy >> i);
      ny = (vx >> i) + vy;
    } else {
      nx = vx + (vy >> i);
      ny = -(vx >> i) + vy;
    }
		vx = nx;
		vy = ny;
		radians += (radians < 0) ? arctangents[i] : -arctangents[i];
	}
  if (i < (sizeof(intermediateKRatio) / sizeof(intermediateKRatio[0]))) {
    vx = mul230(vx, intermediateKRatio[i]);
    vy = mul230(vy, intermediateKRatio[i]);
  }
	c = inv ? -vx : vx;
	s = inv ? -vy : vy;
}

// Calculating atan2 using CORDIC
void tdr::rectp(fix1616 c, fix1616 s, fix1616& r, fix1616& t) {
  bool inv = c < C_ZERO;
  if (inv) {
    c = -c;
    s = -s;
  }
  int64_t angle = 0;
	// vx and vy use 16.16 format
  int32_t vx = c.u;
  int32_t vy = s.u;
  unsigned int i;
  for (i = 0; i < CORDIC_ITERATIONS && vy != 0; ++i) {
    int32_t nx, ny;
    if (vy <= 0) {
      nx = vx - (vy >> i);
      ny = (vx >> i) + vy;
    } else {
      nx = vx + (vy >> i);
      ny = -(vx >> i) + vy;
    }
		vx = nx;
    angle += (vy > 0) ? arctangents[i] : -arctangents[i];
		vy = ny;
  }
  t.u = (angle << 30) / TAU_TIMES_2TT28;
  if (i < (sizeof(intermediateKRatio) / sizeof(intermediateKRatio[0])))
    r.u = (((int64_t) vx) * intermediateK[i]) >> 30;
  else
    r.u = (((int64_t) vx) * CORDIC_K) >> 30;
  if (inv) t.u = (int32_t) (((uint32_t) t.u) + 0x80000000);
}
